/* eslint-disable no-new */

import { rmSync, existsSync, readFileSync } from 'fs';

// NOTE: Spent a lot of time trying to figure out how to get pretty to send
// output to an in memory stream but it looks like that just isn't possible?
// There was an outputStream option but that doesn't seem to be used anymore.
// For now, we write to a file then check the contents of the file. :-(

import { prettyLogger } from './pretty-support';

import {
  SqlConnection, SqlWatch, DirectoriesDefault, Environment, TestOption,
} from '../src/index';

const testConnection = {
  dbname: 'postgres',
  user: 'postgres',
  host: 'localhost',
  port: 5477,

  // committing to git because this is only for local testing
  password: 'localpassword',
};

const sqlWatchSchemaName = 'sql_watch_test';

describe('SqlWatch-lib', () => {
  describe('unit tests', () => {
    const testRootDirectory = './test_unit_01';

    it('SqlWatch should throw an error when connection options are incorrect', () => {
      expect(() => {
        new SqlWatch({
          directories: {
            ...DirectoriesDefault,
            ...{ rootDirectory: testRootDirectory },
          },
          sqlWatchSchemaName,
        });
      }).toThrow('Connection missing required options: host, user, password, database. Required options can be set with environment variables or via the connection parameter');

      // AND no directory will be created
      expect(existsSync(testRootDirectory)).toEqual(false);
    });
  });

  describe('integration tests', () => {
    const testRootDirectory = './test_integration_01';
    let logger = prettyLogger('./test.log');
    const sql = new SqlConnection(logger, testConnection).connection;

    beforeEach(async () => {
      // GIVEN no sql schema directories exists
      if (existsSync(testRootDirectory)) {
        rmSync(testRootDirectory, { recursive: true });
      }
      // AND the test log file has been removed
      if (existsSync('./test.log')) {
        rmSync('./test.log');
      }

      // AND there is no sql watch schema
      await sql`DROP SCHEMA IF EXISTS ${sql(sqlWatchSchemaName)} CASCADE;`;
    });

    afterEach(async () => {
      // THEN remove the sql schema directories generated by sql watch before each run
      if (existsSync(testRootDirectory)) {
        rmSync(testRootDirectory, { recursive: true });
      }
      // AND remove the test log file
      if (existsSync('./test.log')) {
        rmSync('./test.log');
      }
      // AND remove the sql watch schema
      await sql`DROP SCHEMA IF EXISTS ${sql(sqlWatchSchemaName)} CASCADE;`;
    });

    afterAll(async () => {
      // THEN cleanup everything
      await sql.end({ timeout: 4 });
    });

    describe('sql schema directories', () => {
      it(`SqlWatch, without the init option, should create the sql schema
        directories and not create the sql_schema schema in the database`, async () => {
        // GIVEN SqlWatch has not generated any of the sql schema directories
        expect(existsSync(testRootDirectory)).toEqual(false);

        // WHEN SqlWatch is ran against the test root directory
        new SqlWatch({
          directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
          connection: testConnection,
        });

        // THEN the sql schema directories should have been created
        expect(existsSync(testRootDirectory)).toEqual(true);

        // AND there should be no sql watch schema
        const schemaFound = await sql`SELECT * FROM information_schema.schemata WHERE schema_name = 'sql_watch';`;
        expect(schemaFound.length).toEqual(0);
      });
    });

    describe('SqlWatch options', () => {
      beforeEach(async () => {
        // GIVEN a new logger setup
        logger = prettyLogger('./test.log');
      });

      describe('init option', () => {
        it('SqlWatch should support init option with default of production', async () => {
          // GIVEN sql watch is created
          const sqlWatch = new SqlWatch({
            directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
            init: Environment.Production,
            connection: testConnection,
            sqlWatchSchemaName,
          }, logger);

          // WHEN sqlWatch is first ran
          await sqlWatch.run();

          // THEN the environment should be production
          await expect(await sqlWatch.getEnvironment(sql)).toEqual('production');

          // AND the console should notify us what was done
          const content = readFileSync('./test.log').toString('ascii').split('\n');
          expect(content.length).toEqual(5);
          expect(content[0]).toEqual('INFO: Sql Watch successfully:');
          expect(content[1]).toEqual('INFO:   * created/updated the sql_watch schema in postgresql://postgres:*****@localhost:5477/postgres');
          expect(content[2]).toEqual('INFO:   * set the environment in sql_watch.environment to \'production\'.');
          expect(content[3]).toEqual('INFO:   * created/updated required script directories in \'./test_integration_01\'.');
          expect(content[4]).toEqual('');

          // AND nothing should have run
          const run = await sql`SELECT COUNT(*) AS run_count FROM ${sql(sqlWatchSchemaName)}.run;`;
          expect(run[0].run_count).toEqual('0');
        });

        it('SqlWatch should support init option with a non default value', async () => {
          // GIVEN sql watch is created
          const sqlWatch = new SqlWatch({
            directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
            init: Environment.Development,
            connection: testConnection,
            sqlWatchSchemaName,
          }, logger);

          // WHEN sqlWatch is first ran
          await sqlWatch.run();

          // THEN the environment should be development
          await expect(await sqlWatch.getEnvironment(sql)).toEqual('development');

          // AND the console should notify us what was done
          const content = readFileSync('./test.log').toString('ascii').split('\n');
          expect(content.length).toEqual(5);
          expect(content[0]).toEqual('INFO: Sql Watch successfully:');
          expect(content[1]).toEqual('INFO:   * created/updated the sql_watch schema in postgresql://postgres:*****@localhost:5477/postgres');
          expect(content[2]).toEqual('INFO:   * set the environment in sql_watch.environment to \'development\'.');
          expect(content[3]).toEqual('INFO:   * created/updated required script directories in \'./test_integration_01\'.');
          expect(content[4]).toEqual('');

          // AND there should be no entries in the run table
          const runInfo = await sql`SELECT * FROM ${sql(sqlWatchSchemaName)}.run;`;
          expect(runInfo.length).toEqual(0);
        });

        it('SqlWatch should ignore the watch option when init option is provided', async () => {
          // GIVEN sql watch is created
          const sqlWatch = new SqlWatch({
            directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
            init: Environment.Staging,
            watch: true, // this option is ignored
            connection: testConnection,
            sqlWatchSchemaName,
          }, logger);

          // WHEN sqlWatch is first ran
          await sqlWatch.run();

          // THEN the environment should be staging
          await expect(await sqlWatch.getEnvironment(sql)).toEqual('staging');

          // AND the console should notify us what was done
          const content = readFileSync('./test.log').toString('ascii').split('\n');
          expect(content.length).toEqual(5);
          expect(content[0]).toEqual('INFO: Sql Watch successfully:');
          expect(content[1]).toEqual('INFO:   * created/updated the sql_watch schema in postgresql://postgres:*****@localhost:5477/postgres');
          expect(content[2]).toEqual('INFO:   * set the environment in sql_watch.environment to \'staging\'.');
          expect(content[3]).toEqual('INFO:   * created/updated required script directories in \'./test_integration_01\'.');
          expect(content[4]).toEqual('');

          // AND there should be no entries in the run table
          const runInfo = await sql`SELECT * FROM ${sql(sqlWatchSchemaName)}.run;`;
          expect(runInfo.length).toEqual(0);
        });

        it('SqlWatch should error if running SqlWatch without calling init first', async () => {
          // GIVEN sql watch is created
          const sqlWatch = new SqlWatch({
            directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
            watch: true,
            connection: testConnection,
            sqlWatchSchemaName,
          }, logger);

          // WHEN sqlWatch is first ran
          await sqlWatch.run();

          const content = readFileSync('./test.log').toString('ascii').split('\n');
          expect(content.length).toEqual(2);
          expect(content[0]).toEqual('ERROR: SqlWatch has not been initialized. Did you set the init option? If you feel this is in error please check and verify that the sql_watch.environment table exists and has a valid environment entry');
        });
      });

      describe('running sql watch', () => {
        beforeEach(async () => {
          // We need to run SqlWatch init for each test but need to clean up
          // the log file after each init so we don't have to test for/skip the
          // init messages (such as Sql Watch successfully:) that would show up
          // in the log file.
          const options = {
            directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
            init: Environment.Development,
            connection: testConnection,
            sqlWatchSchemaName,
          };

          // GIVEN sql watch is created
          const sqlWatch = new SqlWatch(options, logger);

          // AND sqlWatch is first ran with nothing in any of the directories
          await sqlWatch.run();

          // AND the test log file has been removed
          if (existsSync('./test.log')) {
            rmSync('./test.log');
          }

          // AND a new logger setup
          logger = prettyLogger('./test.log');
        });

        describe('run under development', () => {
          it('SqlWatch should only show "finished" when directories are all empty', async () => {
            const options = {
              directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
              connection: testConnection,
              sqlWatchSchemaName,
            };
            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with no sql files in the sql schema directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            // THEN there should only be an info of finished
            expect(content.length).toEqual(2);
            expect(content[0]).toContain('INFO: Finished in');
            expect(content[1]).toEqual('');

            // AND there should be 1 entry in the run table
            const runInfo = await sql`SELECT * FROM ${sql(sqlWatchSchemaName)}.run;`;
            expect(runInfo.length).toEqual(1);
            expect(runInfo[0].meta_data.options).toEqual({
              level: 'info',
              reset: false,
              watch: false,
              bypass: false,
              runTests: 'always',
              alwaysRun: false,
            });

            const ranAt: Date = runInfo[0].ran_at;

            // AND the last run time should be close to the time that we ran
            expect(ranAt.getTime()).toBeLessThanOrEqual(new Date().getTime());
            expect(ranAt.getTime()).toBeGreaterThanOrEqual(new Date().getTime() - 500);
          });
        });

        describe('reset under development', () => {
          it('SqlWatch should only show reset and "finished" when directories are all empty', async () => {
            const options = {
              directories: { ...DirectoriesDefault, ...{ rootDirectory: testRootDirectory } },
              connection: testConnection,
              sqlWatchSchemaName,
              reset: true,
            };

            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with nothing in any of the directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            // THEN there should only be an info of finished in
            expect(content.length).toEqual(3);
            expect(content[0]).toEqual('INFO: Resetting database');
            expect(content[1]).toContain('INFO: Finished in');
            expect(content[2]).toEqual('');

            // AND there should be 1 entry in the run table
            const runInfo = await sql`SELECT * FROM ${sql(sqlWatchSchemaName)}.run;`;
            expect(runInfo.length).toEqual(1);
            expect(runInfo[0].meta_data.options).toEqual({
              level: 'info',
              reset: true,
              watch: false,
              bypass: false,
              runTests: 'always',
              alwaysRun: false,
            });

            // AND the last run time should be 1970-01-01T00:00:00.000Z because
            // we just reset everything
            expect(runInfo[0].ran_at).toEqual(new Date(0));
          });
        });

        describe('run test and directory options', () => {
          it('SqlWatch should run both tests and run directory by default.', async () => {
            const options = {
              connection: testConnection,
              sqlWatchSchemaName,
            };

            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with nothing in any of the directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            console.log(content);

            // THEN we should see test and non-test files ran
            expect(content.length).toEqual(10);
            expect(content[0]).toEqual('INFO: APPLIED ./db/scripts/prerun/10_set-environment.sql');
            expect(content[1]).toEqual('INFO: APPLIED ./db/scripts/prerun/50_set.test.sql');
            expect(content[2]).toEqual('INFO: APPLIED ./db/scripts/run/020_shared-schema.sql');
            expect(content[3]).toEqual('INFO: APPLIED ./db/scripts/run/021_shared-schema.test.sql');
            expect(content[4]).toEqual('INFO: APPLIED ./db/scripts/run/040_iso-schema.sql');
            expect(content[5]).toEqual('INFO: APPLIED ./db/scripts/run/041_iso-metadata.sql');
            expect(content[6]).toEqual('INFO: APPLIED ./db/scripts/postrun/10_review.sql');
            expect(content[7]).toEqual('INFO: APPLIED ./db/scripts/postrun/50_review.test.sql');
            expect(content[8]).toContain('INFO: Finished in ');
            expect(content[9]).toEqual('');
          });

          it('SqlWatch should run both tests and run directory when always is set', async () => {
            const options = {
              connection: testConnection,
              sqlWatchSchemaName,
              runTests: TestOption.Always,
            };

            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with nothing in any of the directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            // THEN we should see test and non-test files ran
            expect(content.length).toEqual(10);
            expect(content[0]).toEqual('INFO: APPLIED ./db/scripts/prerun/10_set-environment.sql');
            expect(content[1]).toEqual('INFO: APPLIED ./db/scripts/prerun/50_set.test.sql');
            expect(content[2]).toEqual('INFO: APPLIED ./db/scripts/run/020_shared-schema.sql');
            expect(content[3]).toEqual('INFO: APPLIED ./db/scripts/run/021_shared-schema.test.sql');
            expect(content[4]).toEqual('INFO: APPLIED ./db/scripts/run/040_iso-schema.sql');
            expect(content[5]).toEqual('INFO: APPLIED ./db/scripts/run/041_iso-metadata.sql');
            expect(content[6]).toEqual('INFO: APPLIED ./db/scripts/postrun/10_review.sql');
            expect(content[7]).toEqual('INFO: APPLIED ./db/scripts/postrun/50_review.test.sql');
            expect(content[8]).toContain('INFO: Finished in ');
            expect(content[9]).toEqual('');
          });

          it('SqlWatch should only run run directory when tests are skipped', async () => {
            const options = {
              connection: testConnection,
              sqlWatchSchemaName,
              runTests: TestOption.Skip,
            };

            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with nothing in any of the directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            // THEN we should see test and non-test files ran
            expect(content.length).toEqual(7);
            expect(content[0]).toEqual('INFO: APPLIED ./db/scripts/prerun/10_set-environment.sql');
            expect(content[1]).toEqual('INFO: APPLIED ./db/scripts/run/020_shared-schema.sql');
            expect(content[2]).toEqual('INFO: APPLIED ./db/scripts/run/040_iso-schema.sql');
            expect(content[3]).toEqual('INFO: APPLIED ./db/scripts/run/041_iso-metadata.sql');
            expect(content[4]).toEqual('INFO: APPLIED ./db/scripts/postrun/10_review.sql');
            expect(content[5]).toContain('INFO: Finished in ');
            expect(content[6]).toEqual('');
          });

          it('SqlWatch should only tests when set to only run tests', async () => {
            const options = {
              connection: testConnection,
              sqlWatchSchemaName,
              runTests: TestOption.Only,
            };

            // GIVEN sql watch is created
            const sqlWatch = new SqlWatch(options, logger);

            // WHEN sqlWatch is first ran with nothing in any of the directories
            await sqlWatch.run();
            const content = readFileSync('./test.log').toString('ascii').split('\n');

            // THEN we should see test and non-test files ran
            expect(content.length).toEqual(5);
            expect(content[0]).toEqual('INFO: APPLIED ./db/scripts/prerun/50_set.test.sql');
            expect(content[1]).toEqual('INFO: APPLIED ./db/scripts/run/021_shared-schema.test.sql');
            expect(content[2]).toEqual('INFO: APPLIED ./db/scripts/postrun/50_review.test.sql');
            expect(content[3]).toContain('INFO: Finished in ');
            expect(content[4]).toEqual('');
          });
        });
      });
    });
  });
});
